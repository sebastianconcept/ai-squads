---
name: explain-system
alwaysApply: false
---

# Explain System Command

This command generates a narrative understanding of the project's architecture and design, synthesizing insights from onboarding documentation or diving deep into specific subsystems.

## Prerequisites

1. Project must have been adopted (have `docs/` directory with onboarding documentation)
2. Documentation generated by `adopt-project` should exist

## When to Use

Invoke this command when you need to:
- Understand the overall system architecture and how components fit together
- Get a narrative overview that connects the dots between different parts of the codebase
- Dive deep into a specific subsystem or aspect of the system
- Explore how a design change might impact other parts of the system
- Understand the applicability of a pattern or approach to the current architecture
- Investigate where an issue might originate based on the system's design
- Onboard to the project quickly with a coherent mental model
- Prepare for making significant architectural decisions

## How It Works

### 1. Load Project Documentation

Read and synthesize understanding from:
- `docs/README.md` - Project overview
- `docs/mission.md` - Project purpose and goals
- `docs/tech-stack.md` - Technologies and architectural choices
- `docs/DECISIONS.md` - Key architectural decisions and trade-offs
- `docs/roadmap.md` - Future direction and planned changes
- `docs/team.md` - Available agent expertise

### 2. Determine Scope

Ask the user what they need:

**Narrative Overview (default):**
- Generate a cohesive story of how the system works
- Connect components, data flows, and design rationale
- Highlight key abstractions and their relationships
- Explain why things are the way they are

**Deep Dive (specific focus):**
- Focus on a particular subsystem, module, or aspect
- Trace data flows through that area
- Identify dependencies and dependents
- Map out impact radius for changes
- Surface design constraints and trade-offs

### 3. Synthesis Approach

When generating explanations:

**For Narrative Overview:**
1. Start with the "why" - the mission and problem being solved
2. Introduce the major components and their responsibilities
3. Explain how data flows between components
4. Highlight key design decisions and their rationale
5. Connect the tech stack choices to the architectural approach
6. Surface patterns and abstractions used throughout
7. Note areas of complexity or technical debt
8. Relate to roadmap - where is this going?

**For Deep Dive:**
1. Establish boundaries - what's in scope for this subsystem
2. Map internal structure and key abstractions
3. Trace inbound dependencies - what relies on this
4. Trace outbound dependencies - what this relies on
5. Identify invariants and contracts
6. Surface edge cases and error handling patterns
7. Highlight potential impact points for changes
8. Connect to related subsystems

### 4. Interactive Exploration

Be prepared for follow-up questions:
- "What happens if I change X?"
- "How does Y flow through the system?"
- "What would break if Z was modified?"
- "Why was this approach chosen over alternatives?"
- "Where should I look to understand aspect W?"

## Response Patterns

### Narrative Overview Structure

```markdown
## System Overview: [Project Name]

### The Problem & Mission
[Why this system exists, what it solves]

### Architectural Philosophy
[Core design principles guiding decisions]

### Major Components
[High-level breakdown with responsibilities]

### How Things Flow
[Key data/control flows through the system]

### Key Design Decisions
[Important trade-offs and their rationale]

### Technology Choices
[Why specific technologies were chosen]

### Where It's Going
[Roadmap context and future direction]

### Areas of Note
[Complexity, technical debt, areas requiring care]
```

### Deep Dive Structure

```markdown
## Deep Dive: [Subsystem Name]

### Scope & Boundaries
[What this subsystem encompasses]

### Internal Architecture
[Key components, abstractions, patterns]

### Dependencies
**Inbound (what relies on this):**
- [List of dependents]

**Outbound (what this relies on):**
- [List of dependencies]

### Data & Control Flow
[How information moves through this area]

### Key Contracts & Invariants
[What must remain true for this to work]

### Change Impact Analysis
[What could break, what's safe to modify]

### Edge Cases & Error Handling
[How failures are handled, edge conditions]

### Related Subsystems
[Connections to explore next]
```

## Example Usage

```
@explain-system give me a narrative overview of this project

@explain-system dive deep into the authentication subsystem

@explain-system I'm considering changing the database schema - what might be impacted?

@explain-system explain how user requests flow through the system

@explain-system help me understand the caching layer and its implications

@explain-system what's the design philosophy behind the API structure?

@explain-system I see this pattern used everywhere - why?

@explain-system walk me through the payment processing flow

@explain-system if I modify the event system, what breaks?

@explain-system how does the frontend communicate with the backend?
```

## Quality Checklist

Before finalizing an explanation, verify:

**For Narrative Overview:**
- [ ] Connected to project mission and goals
- [ ] All major components introduced and explained
- [ ] Data flows clearly articulated
- [ ] Design decisions have rationale
- [ ] Tech stack choices justified
- [ ] Roadmap context included
- [ ] Complexity areas surfaced
- [ ] Mental model is coherent and memorable

**For Deep Dive:**
- [ ] Boundaries clearly defined
- [ ] Internal structure mapped
- [ ] All dependencies traced
- [ ] Impact areas identified
- [ ] Contracts and invariants stated
- [ ] Edge cases covered
- [ ] Related areas pointed out
- [ ] Actionable insights provided

## Pro Tips

1. **Start Broad, Then Narrow**: Begin with overview context before diving into specifics
2. **Use Analogies**: Compare complex systems to familiar concepts
3. **Draw Connections**: Always relate parts to the whole
4. **Surface the "Why"**: Decisions make more sense with rationale
5. **Anticipate Impact**: When explaining changes, think through consequences
6. **Be Honest About Gaps**: Flag areas with incomplete documentation
7. **Reference Code Locations**: Point to specific files/modules when diving deep
8. **Connect to Team Expertise**: Suggest which agent/specialist to invoke for follow-ups
9. **Think in Flows**: Data flow explanations are often more useful than static descriptions
10. **Relate to User's Goal**: Frame explanations in terms of what they're trying to accomplish

## Related Commands

- `adopt-project` - Generates the documentation this command synthesizes
- `plan-feature` - Use after understanding the system to plan new features
- `review-merge-request` - Apply system understanding when reviewing changes

